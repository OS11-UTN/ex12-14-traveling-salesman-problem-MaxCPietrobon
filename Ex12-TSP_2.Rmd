---
title: "Ex-12 - Traveling Saleman Problem"
author: "Alberto Maximiliano Correa Pietrobon"
output: html_document
---
# Definicion del Problema
1.Try to solve the TSP with a LP matching model Use the scipy linprog package For the cities coordinates
use random points.  
2.Plot the resulting network with the matplotlib library.  
3.Understand the outputs What happend to the optimal path.
4.What are the alternatives to this formulation and their disadvantages  

```{r setup, include=FALSE}
rm( list=ls() )
gc()
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```

```{r}

WishList<-c("Australia","France","china","Canada","Morocco")
#Matriz Distancias y NN 
Md<-matrix(nrow = 5, ncol = 5)
Mnn_R<-matrix(nrow = 5, ncol = 5)
rownames(Mnn_R)=colnames(Mnn_R)=WishList
CV<-c()
set.seed(1979)
for (i in 1:5) {
  for (j in 1:5) {
      if (i==j) {
          Md[i,j]=0
          Mnn_R[i,j]=0
          } else {
          
          Md[i,j]=Md[j,i]=runif(1, min=0, max=100) #esta se la dedico a Python
          CV<-cbind(CV,Md[i,j])
          Mnn_R[i,j]=1
        }
      }
}

#Creo Dataset vacio
TSP_R <- data.frame(Pais_O=character(),
                 Pais_D=character(),
                 Distancia=double(),
                 stringsAsFactors=FALSE)

str(TSP_R)

#Completo Dataset
k<-0
for (i in 1:length(WishList)) {
  for (j in 1:length(WishList)) {
      k<-k+1
      TSP_R[k,"Pais_O"]=WishList[i]
      TSP_R[k,"Pais_D"]=WishList[j]
      TSP_R[k,"Distancia"]=Md[i,j]
      }
}

C_r<-as.vector(t(Md))

```

```{python ImportPyLibraries}
import numpy as np
from scipy.optimize import linprog
```
## Defino Funcion Matriz NodoNodo a NodoArco
```{python Fc_NN2NA}
def nn2na (NN):
  #get every location where exist an arc:
  idxs = np.argwhere(NN)
  #idxs <-retorna un vector c con las posiciones ij con todos los arcos [(i1,j1),(i2,j2),etc]
  #Preallocate NA matrix, dimension is (nodes, arcs)
  NA = np.zeros([NN.shape[0],idxs.shape[0]]).astype(int)
  # Dimension de NA : Filas = dim NN (cantidad de nodos), COL= dim idxs (cantidad de arcos)
  
  #loop in every arc, complete from (1) to (-1)
  for i, arc in enumerate (idxs):
    NA[arc[0],i] = 1 #from
    NA[arc[1],i] = -1 #to
    
  #arc_idxs = [(arc[0], arc[1])] for arc in idxs]
  
  return NA
```
## Detallo el Modelo en terminos de Inv Operativa
```{python}
NN = r.Mnn_R
print(NN)
Aeq_i = nn2na(NN)
print(Aeq_i)
```
```{r}
Aeq_R<-(py$Aeq_i)
dim(Aeq_R)

Aeq_Pr<-matrix(nrow = nrow(Aeq_R), ncol = ncol(Aeq_R))
Aeq_Nr<-matrix(nrow = nrow(Aeq_R), ncol = ncol(Aeq_R))

for (i in 1:nrow(Aeq_R)) {
  for (j in 1:ncol(Aeq_R)) {
    if (Aeq_R[i,j]==1) {Aeq_Pr[i,j]=1; Aeq_Nr[i,j]=0}
    if (Aeq_R[i,j]==-1) {Aeq_Nr[i,j]=1; Aeq_Pr[i,j]=0}
    if (Aeq_R[i,j]==0) {Aeq_Pr[i,j]=0; Aeq_Nr[i,j]=0}
  }
}

#Concatenacion Aeq_Pr con Aeq_Nr
Aeq_Fr<-rbind(Aeq_Pr,Aeq_Nr)

#Creacion Vector beq
beq_r<-c(rep(1, times=ncol(Aeq_Fr)))
```

```{python}
C=r.CV
#print(C)
Aeq=r.Aeq_Fr
#print(Aeq)
beq=r.beq_r
#print(beq)
bounds = tuple ([(0,None) for i in range (0, Aeq.shape[1])])

print ('## inputs del optimizador ## \n'
       'Vector de Costos: %s \n'
       'A_eq Matriz Nodo-Arco: %s \n'
       'b_eq Vector b: %s \n'
       'Bounds of each X arc variable: %s \n' % (C,Aeq, beq,bounds))
```
```{python}
SP = linprog(C,A_eq=Aeq, b_eq=beq,bounds=bounds,method='simplex')
print(SP)
```

# Respuestas
1) El camino mas corto desde el nodo S al T son los vertices s->3->5-t.  
Con el agregado de la resticcion de tiempo <=9 la solucion sigue siendo la misma y el valor de T es 9 (1+3+5).  
Como se puede ver la variable no tiene holgura (Slack) por lo tanto se esta utilizando todo el tiempo disponible.  
Para el **camino mas corto**, el tiempo no puede ser menor que 9.  
2) Dado (1) Cuando se restringe el tiempo en 1 unidad, se podria esperar una solucion no factible.  
No Obstante, el solver linprog de Python asumio a las variables de decision como variables continuas y partio el entero en 2(1/5 y 4/5).
A cada fraccion le asigno un camino: 1/5 (s->2-t) y el resto (4/5) lo asigno al trayecto (s->3->5-t).  
De esta manera, el solver se las ingenio para que el flujo se transporte en T=8.  
3) Este problema no puede ser resuelto con variables continuas, por lo cual habria que especificar que las variables de decision son binarias y resolverlo por programacion mixta. Siendo ese el caso, el resultado seria el mismo que en 1.
Otra forma de resolverlo seria eliminar la restriccion de que la distancia sea minima.  
La solucion 2 no es factible. En la practica y si pienso que el arco "X2t" es una autopista y que por eso se tarda menos a pesar de recorrer mas km se podria tomar la decision de aumentar el costo del transporte (nafta,peajes) de manera tal de ahorrar tiempo (T valdria 4)
